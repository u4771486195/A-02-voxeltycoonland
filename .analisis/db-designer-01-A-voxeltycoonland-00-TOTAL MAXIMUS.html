<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<title>Full Stack Designer - VoxelTycoon Master Architecture</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #111827; color: #d1d5db; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    .header { background-color: #1f2937; padding: 1rem 2rem; border-bottom: 1px solid #374151; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    h1 { color: white; margin: 0; }
    .controls { display: flex; align-items: center; gap: 20px; }
    .legend { display: flex; gap: 20px; font-size: 12px; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .main-container { display: flex; flex-grow: 1; }
    .panel { min-width: 150px; height: 100%; display: flex; flex-direction: column; position: relative; }
    .panel:nth-child(1) { flex: 0 1 15%; }
    .panel:nth-child(3) { flex: 1 1 70%; }
    .panel:nth-child(5) { flex: 0 1 15%; }


code
Code
download
content_copy
expand_less
.splitter { width: 6px; background-color: #374151; cursor: col-resize; flex-shrink: 0; z-index: 100; }
.splitter:hover { background-color: #4b5563; }
.panel-header { padding: 1rem; text-align: center; border-bottom: 1px solid #374151; background-color: #1f2937; }
.panel-header h2 { margin: 0; font-size: 1.5rem; }
.header-r2 { color: #fca5a5; }
.header-r3 { color: #86efac; }
.header-r4 { color: #c4b5fd; }
.canvas { position: relative; width: 100%; flex-grow: 1; overflow: hidden; cursor: grab; }
.canvas:active { cursor: grabbing; }
.connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
.transform-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; z-index: 2; }

.node { position: absolute; border: 3px solid #4b5563; border-radius: 8px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3); font-family: monospace; width: 280px; cursor: move; z-index: 10; user-select: none; padding-top: 30px; }
.node h3 { padding: 8px 12px 8px 12px; margin: 0; border-bottom: 1px solid rgba(0,0,0,0.2); border-radius: 8px 8px 0 0; font-size: 14px; color: white; word-break: break-all; }
.node h3 .path { font-size: 0.8em; color: #9ca3af; display: block; font-weight: normal; }
.node ul { list-style: none; padding: 0; margin: 0; }
.node li { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; position: relative; }
.node li:last-child { border-bottom: none; }
.node .col-name { font-weight: 500; }
.node .col-type { margin-left: auto; color: #9ca3af; }

.db-node { background-color: rgba(196, 181, 253, 0.15); border-color: #a78bfa; }
.db-node h3 { background-color: #8b5cf6; }

.ui-node { background-color: rgba(191, 219, 254, 0.15); border-color: #60a5fa; }
.ui-node h3 { background-color: #3b82f6; }

.code-node { background-color: rgba(134, 239, 172, 0.1); border-color: #4ade80; }
.code-node h3 { background-color: #22c55e; }

.service-node { background-color: rgba(252, 165, 165, 0.1); border-color: #f87171; }
.service-node h3 { background-color: #ef4444; }

.icon-display { position: absolute; top: -32px; left: 50%; transform: translateX(-50%); font-size: 64px; z-index: 12; pointer-events: none; opacity: 0.8; }
</style>

</head>
<body>

<div class="header">
    <h1>Full Stack Designer - VoxelTycoon Master Architecture</h1>
    <div class="controls">
        <div class="legend">
             <div class="legend-item"><svg width="10" height="10" style="background:#3b82f6; border-radius:3px;"></svg> UI</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#22c55e; border-radius:3px;"></svg> Code</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#8b5cf6; border-radius:3px;"></svg> Data/Schema</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#ef4444; border-radius:3px;"></svg> Service</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="panel">
        <div class="panel-header"><h2 class="header-r2">Raptor 2: Legacy</h2></div>
        <div id="canvas-r2" class="canvas"><svg id="connections-r2" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r3">VoxelTycoon Engine</h2></div>
        <div id="canvas-r3" class="canvas"><svg id="connections-r3" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r4">Raptor 4: Future</h2></div>
        <div id="canvas-r4" class="canvas"><svg id="connections-r4" class="connections"></svg><div class="transform-container"></div></div>
    </div>
</div>

<script>
// ===================================================================================
//
//  MASTER DATA SOURCES
//
// ===================================================================================
/*
    ARCHITECTURAL INSIGHTS FOR FUTURE AI ANALYSIS:
    This repository visualizes the architecture of the Voxel Tycoon website, a project built with the Jekyll static site generator and enhanced with a dynamic data-fetching component.

    **Overall Architectural Philosophy:**
    The architecture demonstrates a strong separation of concerns. Content (devlogs, changelogs, supporter lists) is decoupled from presentation and stored in structured data files (Markdown, YAML, CSV). The presentation layer is managed by Jekyll's templating system. A distinct, asynchronous Node.js application provides dynamic functionality by fetching live data from external social media APIs, which is then consumed by the static site during its build process. This hybrid approach allows for a fast, secure static site that can still display up-to-date information.

    **Key File Types and Their Roles:**
    - **Jekyll Files (`_config.yml`, `_layouts/`, `_includes/`, `_posts/`, `pages/`)**: These form the core of the static site generator. `_config.yml` controls the build, `_layouts/` define the main page templates, `_includes/` contain reusable components (like the sidebar), and `_posts/` and `pages/` hold the primary markdown content for blog posts and static pages.
    - **Data Files (`_data/*.yaml`, `*.json`, `*.csv`)**: This directory is the single source of truth for structured content. `changelog.yaml` stores version history, `supporters.csv` lists patrons, and `socials.json` acts as a cache for follower counts. This decoupling is key to maintaining the site.
    - **Node.js Scripts (`scripts/social-count-update/`)**: This is the "backend" of the project. A main script (`index.js`) orchestrates calls to various provider scripts (e.g., `twitter.js`, `discord.js`), which are responsible for querying external APIs for follower counts.
    - **External APIs & Assets (`assets/`, `fonts/`)**: These are external dependencies. The Node.js scripts rely on the public APIs of services like Twitter, Discord, and YouTube. The Jekyll site relies on static assets like images, videos, and fonts for rendering.

    **The Data Flow Pipeline:**
    The system operates in two distinct phases: a dynamic data update phase and a static site generation phase.
    1.  **Data Update (Dynamic):**
        a. A scheduled job (e.g., a cron job or GitHub Action) executes the main script `scripts/social-count-update/index.js`.
        b. This script invokes individual "provider" scripts, each responsible for querying a specific social media API (Twitter, Reddit, etc.).
        c. The main script reads the existing `_data/socials.json` file to compare old and new follower counts.
        d. It then overwrites `_data/socials.json` with the fresh data.
        e. If counts have changed, it sends a notification summary via the Telegram API.
    2.  **Site Generation (Static):**
        a. The Jekyll build process is triggered (e.g., on a push to the repository or a schedule).
        b. Jekyll reads `_config.yml` and all content, layout, and data files.
        c. During rendering, templates like `_includes/sidebar.md` directly access the data from `_data/socials.json` to display the latest follower counts. Similarly, the changelog page reads from `_data/changelog.yaml`.
        d. Jekyll outputs the final, static HTML, CSS, and JavaScript files that constitute the public website.
*/
const schemaR2 = { tables: [], relationships: [] };
const schemaR4 = { tables: [], relationships: [] };

const schemaR3 = {
    tables: [
        { id: 1, name: "Jekyll Site Configuration", path: "_config.yml", nodeType: "code", pos: { x: 450, y: 50 }, icon: "âš™ï¸", columns: [ { name: "plugins" }, { name: "permalink" }, { name: "defaults" }, { name: "description" } ] },
        { id: 2, name: "Gemfile", path: "Gemfile", nodeType: "code", pos: { x: 450, y: 350 }, icon: "ðŸ’Ž", columns: [ { name: "jekyll-redirect-from" }, { name: "jemoji" }, { name: "jekyll-feed" } ] },
        { id: 3, name: "Default Layout", path: "_layouts/default.html", nodeType: "ui", pos: { x: 50, y: 50 }, icon: "ðŸ“‘", columns: [ { name: "include head.html" }, { name: "include background-video.html" }, { name: "include sidebar.md" }, { name: "include inner_footer.html" } ] },
        { id: 4, name: "Post Layout", path: "_layouts/post.html", nodeType: "ui", pos: { x: 50, y: 350 }, icon: "ðŸ“°", columns: [ { name: "layout: default" }, { name: "{{ content }}" }, { name: "page.previous / page.next" } ] },
        { id: 5, name: "Homepage", path: "index.html", nodeType: "ui", pos: { x: 50, y: 650 }, icon: "ðŸ ", columns: [ { name: "layout: default" }, { name: "include home.md" } ] },
        { id: 6, name: "Devlog Posts", path: "_posts/", nodeType: "ui", pos: { x: 50, y: 950 }, icon: "âœï¸", columns: [ { name: "layout: post" }, { name: "category: devlog" }, { name: "Frontmatter (title, thumb)" } ] },
        { id: 7, name: "Changelog Page", path: "pages/eng/changelog.html", nodeType: "ui", pos: { x: 50, y: 1250 }, icon: "ðŸ“œ", columns: [ { name: "layout: post" }, { name: "Iterates site.data.changelog" } ] },
        { id: 8, name: "Donate Page", path: "pages/eng/donate.md", nodeType: "ui", pos: { x: 50, y: 1550 }, icon: "ðŸ’–", columns: [ { name: "layout: default" }, { name: "include hall_of_fame.md" } ] },
        { id: 9, name: "Sidebar Include", path: "_includes/sidebar.md", nodeType: "ui", pos: { x: 50, y: 1850 }, icon: "âž¡ï¸", columns: [ { name: "Displays Social Counts" }, { name: "Links (Devlog, Roadmap)" }, { name: "StickySidebar.js" } ] },
        { id: 10, name: "SCSS Stylesheets", path: "_sass/", nodeType: "ui", pos: { x: 50, y: 2150 }, icon: "ðŸŽ¨", columns: [ { name: "_variables.scss" }, { name: "_mixins.scss" }, { name: "page-*.scss" }, { name: "Imports fonts" } ] },
        { id: 11, name: "Changelog Data", path: "_data/changelog.yaml", nodeType: "db", pos: { x: 850, y: 50 }, icon: "ðŸ“š", columns: [ { name: "version" }, { name: "date" }, { name: "text" }, { name: "groups (gameplay, fixes...)" } ] },
        { id: 12, name: "Social Counts Data", path: "_data/socials.json", nodeType: "db", pos: { x: 850, y: 350 }, icon: "ðŸ“Š", columns: [ { name: "vk" }, { name: "tw" }, { name: "fb" }, { name: "yt" }, { name: "dd" }, { name: "rd" } ] },
        { id: 13, name: "Supporters Data", path: "_data/supporters.csv", nodeType: "db", pos: { x: 850, y: 650 }, icon: "ðŸ‘¥", columns: [ { name: "name" }, { name: "tier" } ] },
        { id: 14, name: "Social Count Update Script", path: "scripts/social-count-update/index.js", nodeType: "code", pos: { x: 450, y: 650 }, icon: "ðŸ¤–", columns: [ { name: "main()" }, { name: "reads/writes socials.json" }, { name: "sends to Telegram" } ] },
        { id: 15, name: "Telegram Bot Script", path: "scripts/social-count-update/telegram.js", nodeType: "code", pos: { x: 450, y: 950 }, icon: "âœˆï¸", columns: [ { name: "send(message)" } ] },
        { id: 16, name: "Discord Counter", path: "count-providers/discord.js", nodeType: "code", pos: { x: 450, y: 1250 }, icon: "ðŸ’¬", columns: [ { name: "count()" } ] },
        { id: 17, name: "Facebook Counter", path: "count-providers/facebook.js", nodeType: "code", pos: { x: 450, y: 1550 }, icon: "ðŸ‘", columns: [ { name: "count()" } ] },
        { id: 18, name: "Reddit Counter", path: "count-providers/reddit.js", nodeType: "code", pos: { x: 450, y: 1850 }, icon: "ðŸ‘½", columns: [ { name: "count()" } ] },
        { id: 19, name: "Twitter Counter", path: "count-providers/twitter.js", nodeType: "code", pos: { x: 450, y: 2150 }, icon: "ðŸ¦", columns: [ { name: "count()" } ] },
        { id: 20, name: "VK Counter", path: "count-providers/vk.js", nodeType: "code", pos: { x: 450, y: 2450 }, icon: "ðŸ¤", columns: [ { name: "count()" } ] },
        { id: 21, name: "YouTube Counter", path: "count-providers/youtube.js", nodeType: "code", pos: { x: 450, y: 2750 }, icon: "â–¶ï¸", columns: [ { name: "count()" } ] },
        { id: 22, name: "External APIs", path: "Third-Party Services", nodeType: "service", pos: { x: 1250, y: 50 }, icon: "â˜ï¸", columns: [ { name: "api.telegram.org" }, { name: "discordapp.com/api" }, { name: "graph.facebook.com" }, { name: "oauth.reddit.com" }, { name: "api.twitter.com" }, { name: "api.vk.com" }, { name: "googleapis.com/youtube" } ] },
        { id: 23, a_id: "assets-img", name: "Image Assets", path: "assets/", nodeType: "service", pos: { x: 1250, y: 350 }, icon: "ðŸ–¼ï¸", columns: [ { name: "*.png" }, { name: "*.gif" }, { name: "*.jpg" } ] },
        { id: 24, a_id: "assets-video", name: "Video Assets", path: "assets/", nodeType: "service", pos: { x: 1250, y: 650 }, icon: "ðŸŽ¬", columns: [ { name: "*.mp4" } ] },
        { id: 25, a_id: "assets-fonts", name: "Font Assets", path: "fonts/", nodeType: "service", pos: { x: 1250, y: 950 }, icon: "ðŸ”¤", columns: [ { name: "*.otf" } ] }
    ],
    relationships: [
        { from: { table: "Post Layout" }, to: { table: "Default Layout" } },
        { from: { table: "Homepage" }, to: { table: "Default Layout" } },
        { from: { table: "Changelog Page" }, to: { table: "Post Layout" } },
        { from: { table: "Devlog Posts" }, to: { table: "Post Layout" } },
        { from: { table: "Donate Page" }, to: { table: "Default Layout" } },
        { from: { table: "Default Layout" }, to: { table: "Sidebar Include" }, type: 'flow' },
        { from: { table: "Default Layout" }, to: { table: "SCSS Stylesheets" }, type: 'flow' },
        { from: { table: "Homepage" }, to: { table: "Video Assets" }, type: 'read' },
        { from: { table: "Devlog Posts" }, to: { table: "Image Assets" }, type: 'read' },
        { from: { table: "SCSS Stylesheets" }, to: { table: "Font Assets" }, type: 'read' },
        { from: { table: "Changelog Page" }, to: { table: "Changelog Data" }, type: 'read' },
        { from: { table: "Donate Page" }, to: { table: "Supporters Data" }, type: 'read' },
        { from: { table: "Sidebar Include" }, to: { table: "Social Counts Data" }, type: 'read' },
        { from: { table: "Social Count Update Script", column: "reads/writes socials.json" }, to: { table: "Social Counts Data" }, type: 'write' },
        { from: { table: "Social Count Update Script" }, to: { table: "Telegram Bot Script" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "Discord Counter" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "Facebook Counter" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "Reddit Counter" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "Twitter Counter" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "VK Counter" }, type: 'flow' },
        { from: { table: "Social Count Update Script" }, to: { table: "YouTube Counter" }, type: 'flow' },
        { from: { table: "Telegram Bot Script" }, to: { table: "External APIs", column: "api.telegram.org" }, type: 'read' },
        { from: { table: "Discord Counter" }, to: { table: "External APIs", column: "discordapp.com/api" }, type: 'read' },
        { from: { table: "Facebook Counter" }, to: { table: "External APIs", column: "graph.facebook.com" }, type: 'read' },
        { from: { table: "Reddit Counter" }, to: { table: "External APIs", column: "oauth.reddit.com" }, type: 'read' },
        { from: { table: "Twitter Counter" }, to: { table: "External APIs", column: "api.twitter.com" }, type: 'read' },
        { from: { table: "VK Counter" }, to: { table: "External APIs", column: "api.vk.com" }, type: 'read' },
        { from: { table: "YouTube Counter" }, to: { table: "External APIs", column: "googleapis.com/youtube" }, type: 'read' },
        { from: { table: "Jekyll Site Configuration" }, to: { table: "Gemfile" } }
    ]
};


// ===================================================================================
//  RENDERING LOGIC
// ===================================================================================
function initializeCanvas(canvasId, schema) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const transformContainer = canvas.querySelector('.transform-container');
    const svg = canvas.querySelector('.connections');
    let state = { scale: 0.7, panX: 50, panY: 50, isPanning: false, lastMouse: { x: 0, y: 0 } };

    function render() {
        if (!transformContainer || !svg) return;
        transformContainer.innerHTML = '';
        transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        
        schema.tables.forEach(table => {
            const node = document.createElement('div');
            node.id = `${canvasId}-${table.id}`;
            node.classList.add('node', `${table.nodeType}-node`);
            node.style.left = `${table.pos.x}px`;
            node.style.top = `${table.pos.y}px`;

            const header = document.createElement('h3');
            const pathSpan = table.path ? `<span class="path">${table.path}</span>` : '';
            header.innerHTML = `${pathSpan}${table.name}`;

            const list = document.createElement('ul');
            list.innerHTML = table.columns.map(col => {
                const colName = typeof col === 'string' ? col : col.name;
                const colType = typeof col === 'string' ? '' : col.type;
                const colId = colName.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                return `<li id="${canvasId}-${table.id}-${colId}"><span class="col-name">${colName}</span>${colType ? `<span class="col-type">${colType}</span>` : ''}</li>`;
            }).join('');
            
            if (table.icon) {
                const iconDisplay = document.createElement('div');
                iconDisplay.className = 'icon-display';
                iconDisplay.textContent = table.icon;
                node.appendChild(iconDisplay);
            }

            node.appendChild(header);
            node.appendChild(list);
            transformContainer.appendChild(node);
        });
        updateConnections();
    }
    
    function getElementPortPosition(elId) {
        const el = document.getElementById(elId);
        if (!el) return null;
        const parentNode = el.closest('.node');
        if (!parentNode) return null;
        const isNodeConnection = el.classList.contains('node');
        
        const parentRect = parentNode.getBoundingClientRect();
        const elRect = isNodeConnection ? parentRect : el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        const y = isNodeConnection ? (parentRect.top - canvasRect.top + parentRect.height / 2) : (elRect.top - canvasRect.top + elRect.height / 2);
        const leftX = (parentRect.left - canvasRect.left);
        const rightX = (parentRect.right - canvasRect.left);

        return { left: {x: leftX, y: y}, right: {x: rightX, y: y} };
    }

    function updateConnections() {
        if (!svg) return;
        svg.innerHTML = `<defs>
            <marker id="arrowhead-read-${canvasId}" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#6b7283" /></marker>
            <marker id="arrowhead-write-${canvasId}" markerWidth="12" markerHeight="9" refX="10" refY="4.5" orient="auto"><polygon points="0 0, 12 4.5, 0 9" fill="#86efac" /></marker>
            <marker id="arrowhead-flow-${canvasId}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#9ca3af" /></marker>
        </defs>`;
        
        const idMap = new Map(schema.tables.map(t => [t.name, t.id]));

        schema.relationships.forEach(rel => {
            const fromId = idMap.get(rel.from.table);
            const toId = idMap.get(rel.to.table);
            if(!fromId || !toId) return;

            let fromColName = rel.from.column ? (typeof rel.from.column === 'string' ? rel.from.column : rel.from.column.name) : '';
            let toColName = rel.to.column ? (typeof rel.to.column === 'string' ? rel.to.column : rel.to.column.name) : '';
            
            let fromElId = fromColName ? `${canvasId}-${fromId}-${fromColName.replace(/\s+/g, '-').replace(/[^\w-]/g, '')}` : `${canvasId}-${fromId}`;
            if (!document.getElementById(fromElId)) fromElId = `${canvasId}-${fromId}`;

            let toElId = toColName ? `${canvasId}-${toId}-${toColName.replace(/\s+/g, '-').replace(/[^\w-]/g, '')}` : `${canvasId}-${toId}`;
            if (!document.getElementById(toElId)) toElId = `${canvasId}-${toId}`;
            
            const fromPorts = getElementPortPosition(fromElId);
            const toPorts = getElementPortPosition(toElId);
            if (!fromPorts || !toPorts) return;

            const fromPos = toPorts.right.x < fromPorts.left.x ? fromPorts.left : fromPorts.right;
            const toPos = toPorts.right.x < fromPorts.left.x ? toPorts.right : toPorts.left;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);

            if (rel.type === 'write') {
                line.setAttribute('stroke', '#86efac'); line.setAttribute('stroke-width', 4); line.setAttribute('marker-end', `url(#arrowhead-write-${canvasId})`);
            } else if (rel.type === 'flow') {
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2); line.setAttribute('stroke-dasharray', `6,6`); line.setAttribute('marker-end', `url(#arrowhead-flow-${canvasId})`);
            } else {
                line.setAttribute('stroke', '#6b7283'); line.setAttribute('stroke-width', 2); line.setAttribute('marker-end', `url(#arrowhead-read-${canvasId})`);
            }
            svg.appendChild(line);
        });
    }

    let activeNode = null, offset = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        const targetNode = e.target.closest('.node');
        if (targetNode) {
            activeNode = targetNode;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (!tableData) return;
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            offset.x = mouseX - tableData.pos.x;
            offset.y = mouseY - tableData.pos.y;
            activeNode.style.zIndex = 11;
        } else {
            state.isPanning = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (activeNode) {
            e.preventDefault();
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (tableData) {
                tableData.pos.x = mouseX - offset.x;
                tableData.pos.y = mouseY - offset.y;
                activeNode.style.left = `${tableData.pos.x}px`;
                activeNode.style.top = `${tableData.pos.y}px`;
                updateConnections();
            }
        } else if (state.isPanning) {
            e.preventDefault();
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.panX += dx;
            state.panY += dy;
            transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            updateConnections();
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (activeNode) { activeNode.style.zIndex = 10; activeNode = null; }
        state.isPanning = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const oldScale = state.scale;
        const zoomFactor = 1.1;
        state.scale *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        state.scale = Math.max(0.1, Math.min(state.scale, 2.5));
        state.panX = mouseX - (mouseX - state.panX) * (state.scale / oldScale);
        state.panY = mouseY - (mouseY - state.panY) * (state.scale / oldScale);
        render();
    });

    render();
    return { render, updateConnections };
}

const canvases = [
    initializeCanvas('canvas-r2', schemaR2),
    initializeCanvas('canvas-r3', schemaR3),
    initializeCanvas('canvas-r4', schemaR4)
];

document.querySelectorAll('.splitter').forEach(splitter => {
    splitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const prevPanel = splitter.previousElementSibling;
        const startX = e.clientX;
        const initialPrevWidth = prevPanel.getBoundingClientRect().width;
        
        const onMouseMove = (moveEvent) => {
            let newPrevWidth = initialPrevWidth + (moveEvent.clientX - startX);
            const MIN_WIDTH = 150;
            if (newPrevWidth < MIN_WIDTH) newPrevWidth = MIN_WIDTH;
            prevPanel.style.flex = `0 0 ${newPrevWidth}px`;
            canvases.forEach(c => c && c.render());
        };
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
});

window.addEventListener('resize', () => {
    canvases.forEach(c => c && c.render());
});
</script>

</body>
</html>